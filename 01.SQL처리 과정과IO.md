# SQL처리 과정과 I/O
## 1.1 SQL파싱과 최적화
### 1.1.1 구조적, 집합적, 선언적 질의 언어
SQL은 기본적으로 구조적이고, 집합적이고, 선언적인 질의 언어다. 하지만 그 과정은 절차적일 수밖에 없다. 즉 프로시저가 팔요한데 그런 프로시저를 만들어내는 DBMS 내부 엔진이 바로 SQL 옵티마이저이다. 

DBMS 내부에서 프로시저를 작성하고 컴파일해서 실행 가능한 상태로 만드는 전 과정을 'SQL최적화'라고 한다.

### 1.1.2 SQL 최적화
1. SQL 파싱 : 사용자로부터 SQL을 전달받으면 가장 먼저 SQL 파서가 파싱을 진행한다. (파싱트리 생성 -> Syntax[문법적 오류] 체크 -> Semantic[의미상 오류] 체크)
2. SQL 최적화 : 옵티마이저는 미리 수집한 시스템 및 오브젝트 통계정보를 바탕으로 다양한 실행경로를 생성해서 비교한 후 가장 효율적인 하나를 선택한다.(DB성능을 결정하는 핵심엔진)
3. 로우소스생성 : 옵티마이저가 선택한 실행경로를 실제 실행 가능한 코드 또는 프로시저 형태로 포맷팅 하는 단계

### 1.1.3 SQL 옵티마이저
옵티마이저는 사용자가 원하는 작업을 가장 효율적으로 수행할 수 있는 최적의 데이터 액세스 경로를 선택해 주는 DBMS의 핵심 엔진이다.

[최적화 단계]
* 사용자로부터 전달받은 쿼리를 수행하는데 후보가 될만한 실행계획들을 찾아낸다.
* 데이터 딕셔너리에 미리 수집해둔 오브젝트 통계 및 시스템 통계정보를 이용해 각 실행계획의 예상비용을 산정한다.
* 최저 비용을 나타내는 실행계획을 선택한다.

### 1.1.4 실행계획과 비용
옵티마이저의 '실행계획'은 옵티마이저가 생성한 처리절차를 사용자가 확인할 수 있게 트리구조로 표현한 것이다. 옵티마이저가 실행계획을 수행하는 기준은 '비용'이다. 비용은 쿼리를 수행하는 동안 발생할 것으로 예상하는 I/O횟수 또는 예상 소요시간을 표현한 값이다. 비용은 예상치이므로 실게 수행할 때 발생하는 I/O 또는 시간과 많은 차이가 난다.

### 1.1.5 옵티마이저 힌트
옵티마이저의 선택이 항상 최선은 아니다. 대부분 좋은 선택을 하지만 완벽하지 않다. 그래서 개발자가 직접 더 효율적인 액세스 경로를 찾아낼 수 있는데 이때 사용하는 것이 옵티마이저 힌트이다. 힌트를 이용하여 데이터 액세스 경로를 바꿀 수 있다. 

__/*+ INDEX(A 고객_PK) */__ 식으로 사용한다.

[주의사항]
* 힌트안에 인자를 나열할 땐 , 콤마를 사용한다. 단, 힌트와 힌트 사이에 사용하면 안 된다.
* 테이블을 지정할 때 스키마명까지 명시하면 안된다.
* ALIAS를 지정했다면 힌트에도 반드시 ALIAS를 사용해야한다.

## 1.2 SQL 공유 및 재사용
### 1.2.1 소프트 파싱 VS 하드 파싱
SQL 파싱, 최적화, 로우 소스 생성 과정을 거쳐 생성한 내부 프로시저를 반복 재사용할 수 있도록 캐싱해 두는 메모리 공간을 '라이브러리 캐시'라고 한다.

라이브러리 캐시는 SGA(System Global Area)의 구성요소이다. SGA는 서버 프로세스와 백그라운드 프로세스가 공통으로 액세스하는 데이터와 제어 구조를 캐싱하는 메모리 공간이다.

사용자가 SQL문을 전달 -> DBMS는 SQL파싱 후 해당 SQL이 라이브러리 캐시에 존재하는지 확인 캐시에서 찾으면 곧바로 실행(소프트 파싱), 찾지 못하면 최적화 및 로우소스 생성단계(하드 파싱)를 거친다.

SQL 최적화 과정이 왜 하드한가? 옵티마이저가 SQL을 최적화할 때 순시간에 엄청나게 많은 연산을 한다. 그 과정에서 옵티마이저가 사용하는 정보는 다음과 같다.

* 테이블, 컬럼, 인덱스 구조에 대한 기본 정보
* 오브젝트 통계 : 테이블 통계, 인덱스 통계, 컬럼 통계
* 시스템 통계 : CPU속도, Single Block I/O속도, Multiblock I/O속도 등
* 옵티마이저 관련 파라미터 

데이터 베이스에서 사용하는 과정은 대부분 I/O 작업에 집중되는 반면, 하드 파싱은 CPU를 많이 소비하는 몇 안 되는 작업 중 하나다. 이렇게 하드한 작업을 거쳐 생성한 내부 프로시저를 한 번만 사용하고 버리면 비효율적이기 때문에 라이브러리 캐시가 필요한 이유가 여기에 있다.

### 1.2.2 바인드 변수의 중요성
__이름없는 SQL 문제__ : 사용자 정의 함수/프로시저, 트리거, 패키지 등은 생성할 때부터 이름을 갖는다. 컴파일한 상태로 딕셔너리에 저장되며, 사용자가 삭제하지 않는 한 영구적으로 보관된다. 실행할 때 라이브러리 캐시에 적재함으로써 여러 사용자가 공유하면서 재사용한다.

반면, SQL은 이름이 따로 없다. 딕셔너리에 저장하지도 않고, 처음 실행할 때 최적화 과정을 거쳐 동적으로 생성한 내부 프로시저를 라이브러리 캐시에 적재함으로써 여러 사용자가 공유하면서 재사용한다. 캐시 공간이 부족하면 버려졌다가 다음에 다시 실행할 때 똑같은 최적화 과정을 거쳐 캐시에 적재된다. SQL 자체가 이름이기 때문에 텍스트 중 작은 부분이라도 수정되면 그 순간 다른 객체가 새로 탄생하는 구조다.

__공유가능 SQL__ : 라이브러리 캐시에서 SQL을 찾기 위해 사용하는 키 값이 SQL문 그 자체이므로 대소문자만 달라도 모두 다른 SQL이다. 실행할 때 각각 최적화를 진행하고 라이브러리 캐시에서 별도 공간을 사용한다.

예) 로그인 프로그램 작성시 "SELECT * FROM CUTOMER WHERE LOGIN_ID =" +login_id + "'"; 로 한다면 로그인 시도한 아이디 별로 각각 라이브러리 캐시에 적재된다. 이렇게 되면 I/O는 거의 발생하지 않음에도 불구하고 CPU 사용률이 급격히 올라가게 된다. 이때 프로시저를 여러개 생성하는 것이 아니라 로그인 ID를 파라미터로 받는 프로시저 하나를 공유하면 재사용하는것이 마땅하다. 이렇게 하기위해 사용되는 방법인 '바인드 변수'다. 

"SELECT * FROM CUSTOMER WHERE LOGIN_ID = ?"; ... st.setString(1, login_id);  //?가 바인딩 변수
