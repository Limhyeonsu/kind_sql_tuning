# SQL처리 과정과 I/O
## 1.1 SQL파싱과 최적화
### 1.1.1 구조적, 집합적, 선언적 질의 언어
SQL은 기본적으로 구조적이고, 집합적이고, 선언적인 질의 언어다. 하지만 그 과정은 절차적일 수밖에 없다. 즉 프로시저가 팔요한데 그런 프로시저를 만들어내는 DBMS 내부 엔진이 바로 SQL 옵티마이저이다. 

DBMS 내부에서 프로시저를 작성하고 컴파일해서 실행 가능한 상태로 만드는 전 과정을 'SQL최적화'라고 한다.

### 1.1.2 SQL 최적화
1. SQL 파싱 : 사용자로부터 SQL을 전달받으면 가장 먼저 SQL 파서가 파싱을 진행한다. (파싱트리 생성 -> Syntax[문법적 오류] 체크 -> Semantic[의미상 오류] 체크)
2. SQL 최적화 : 옵티마이저는 미리 수집한 시스템 및 오브젝트 통계정보를 바탕으로 다양한 실행경로를 생성해서 비교한 후 가장 효율적인 하나를 선택한다.(DB성능을 결정하는 핵심엔진)
3. 로우소스생성 : 옵티마이저가 선택한 실행경로를 실제 실행 가능한 코드 또는 프로시저 형태로 포맷팅 하는 단계

### 1.1.3 SQL 옵티마이저
옵티마이저는 사용자가 원하는 작업을 가장 효율적으로 수행할 수 있는 최적의 데이터 액세스 경로를 선택해 주는 DBMS의 핵심 엔진이다.

[최적화 단계]
* 사용자로부터 전달받은 쿼리를 수행하는데 후보가 될만한 실행계획들을 찾아낸다.
* 데이터 딕셔너리에 미리 수집해둔 오브젝트 통계 및 시스템 통계정보를 이용해 각 실행계획의 예상비용을 산정한다.
* 최저 비용을 나타내는 실행계획을 선택한다.

### 1.1.4 실행계획과 비용
옵티마이저의 '실행계획'은 옵티마이저가 생성한 처리절차를 사용자가 확인할 수 있게 트리구조로 표현한 것이다. 옵티마이저가 실행계획을 수행하는 기준은 '비용'이다. 비용은 쿼리를 수행하는 동안 발생할 것으로 예상하는 I/O횟수 또는 예상 소요시간을 표현한 값이다. 비용은 예상치이므로 실게 수행할 때 발생하는 I/O 또는 시간과 많은 차이가 난다.

### 1.1.5 옵티마이저 힌트
옵티마이저의 선택이 항상 최선은 아니다. 대부분 좋은 선택을 하지만 완벽하지 않다. 그래서 개발자가 직접 더 효율적인 액세스 경로를 찾아낼 수 있는데 이때 사용하는 것이 옵티마이저 힌트이다. 힌트를 이용하여 데이터 액세스 경로를 바꿀 수 있다. 

__/*+ INDEX(A 고객_PK) */__ 식으로 사용한다.

[주의사항]
* 힌트안에 인자를 나열할 땐 , 콤마를 사용한다. 단, 힌트와 힌트 사이에 사용하면 안 된다.
* 테이블을 지정할 때 스키마명까지 명시하면 안된다.
* ALIAS를 지정했다면 힌트에도 반드시 ALIAS를 사용해야한다.

## 1.2 SQL 공유 및 재사용
### 1.2.1 소프트 파싱 VS 하드 파싱
SQL 파싱, 최적화, 로우 소스 생성 과정을 거쳐 생성한 내부 프로시저를 반복 재사용할 수 있도록 캐싱해 두는 메모리 공간을 '라이브러리 캐시'라고 한다.

라이브러리 캐시는 SGA(System Global Area)의 구성요소이다. SGA는 서버 프로세스와 백그라운드 프로세스가 공통으로 액세스하는 데이터와 제어 구조를 캐싱하는 메모리 공간이다.

사용자가 SQL문을 전달 -> DBMS는 SQL파싱 후 해당 SQL이 라이브러리 캐시에 존재하는지 확인 캐시에서 찾으면 곧바로 실행(소프트 파싱), 찾지 못하면 최적화 및 로우소스 생성단계(하드 파싱)를 거친다.

SQL 최적화 과정이 왜 하드한가? 옵티마이저가 SQL을 최적화할 때 순시간에 엄청나게 많은 연산을 한다. 그 과정에서 옵티마이저가 사용하는 정보는 다음과 같다.

* 테이블, 컬럼, 인덱스 구조에 대한 기본 정보
* 오브젝트 통계 : 테이블 통계, 인덱스 통계, 컬럼 통계
* 시스템 통계 : CPU속도, Single Block I/O속도, Multiblock I/O속도 등
* 옵티마이저 관련 파라미터 

데이터 베이스에서 사용하는 과정은 대부분 I/O 작업에 집중되는 반면, 하드 파싱은 CPU를 많이 소비하는 몇 안 되는 작업 중 하나다. 이렇게 하드한 작업을 거쳐 생성한 내부 프로시저를 한 번만 사용하고 버리면 비효율적이기 때문에 라이브러리 캐시가 필요한 이유가 여기에 있다.

### 1.2.2 바인드 변수의 중요성
__이름없는 SQL 문제__ : 사용자 정의 함수/프로시저, 트리거, 패키지 등은 생성할 때부터 이름을 갖는다. 컴파일한 상태로 딕셔너리에 저장되며, 사용자가 삭제하지 않는 한 영구적으로 보관된다. 실행할 때 라이브러리 캐시에 적재함으로써 여러 사용자가 공유하면서 재사용한다.

반면, SQL은 이름이 따로 없다. 딕셔너리에 저장하지도 않고, 처음 실행할 때 최적화 과정을 거쳐 동적으로 생성한 내부 프로시저를 라이브러리 캐시에 적재함으로써 여러 사용자가 공유하면서 재사용한다. 캐시 공간이 부족하면 버려졌다가 다음에 다시 실행할 때 똑같은 최적화 과정을 거쳐 캐시에 적재된다. SQL 자체가 이름이기 때문에 텍스트 중 작은 부분이라도 수정되면 그 순간 다른 객체가 새로 탄생하는 구조다.

__공유가능 SQL__ : 라이브러리 캐시에서 SQL을 찾기 위해 사용하는 키 값이 SQL문 그 자체이므로 대소문자만 달라도 모두 다른 SQL이다. 실행할 때 각각 최적화를 진행하고 라이브러리 캐시에서 별도 공간을 사용한다.

예) 로그인 프로그램 작성시 "SELECT * FROM CUTOMER WHERE LOGIN_ID =" +login_id + "'"; 로 한다면 로그인 시도한 아이디 별로 각각 라이브러리 캐시에 적재된다. 이렇게 되면 I/O는 거의 발생하지 않음에도 불구하고 CPU 사용률이 급격히 올라가게 된다. 이때 프로시저를 여러개 생성하는 것이 아니라 로그인 ID를 파라미터로 받는 프로시저 하나를 공유하면 재사용하는것이 마땅하다. 이렇게 하기위해 사용되는 방법인 '바인드 변수'다. 

"SELECT * FROM CUSTOMER WHERE LOGIN_ID = ?"; ... st.setString(1, login_id);  //?가 바인딩 변수

## 1.3 데이터 저장 구조 및 I/O 메커니즘
### 1.3.1 SQL이 느린 이유
SQL이 느린 이유는 십중팔구 I/O 때문이다(디스크I/O). I/O를 설명하자면 잠(sleep)이라고 할 수 있다. OS 또는 I/O서브시스템이 I/O를 처리하는 동안 프로세스는 잠을 자기 때문이다. 

### 1.3.2 데이터베이스 저장 구조
데이터를 저장하려면 먼저 테이블 스페이스를 생성해야한다. 테이블스페이스는 세그먼트를 담는 콘테이너로서 여러 개의 데이터파일로 구성된다.

테이블 스페이스 생성 -> 세그먼트 생성(여러 익스텐트로 구성, 파티션 구조가 아니라면 테이블, 인덱스도 하나의 세그먼트다. / 파티션 구조라면 각 파티션이 하나의 세그먼트가 된다.) *익스텐트는 공간을 확장하는 단위이며 연속된 블록들의 집합이다.

익스텐트 단위로 공간을 확장하지만 사용자가 입력한 레코드를 실제로 저장하는 공간은 데이터 블록이가. 한 블록은 하나의 테이블이 독점하고, 한 블록에 저장된 레코드는 모두 같은 테이블 레코드다. 한 익스텐트도 하나의 테이블이 독점한다. 즉 한 익스텐트에 담긴 블록은 모두 같은 테이블 블록이다.

세그먼트의 공간이 부족해지면 테이블 스페이스로부터 익스텐트를 추가로 할당받는데 이렇게 할당된 익스텐트는 서로 다른 데이터 파일에 위치할 가능성이 더 높다.

**익스턴트 내 블록은 서로 인접한 연속된 공간이지만 익스텐트끼리는 연속된 공간이 아니다.

[DBA]

모든 데이터 블록은 디스크 상에서 몇 번 데이터파일의 몇 번째 블록인지를 나타내는 자신만의 고유 주소값을 갖는다. 이 주소값을 DBA라고 부른다. 읽고 쓰는 단위가 블록이므로 데이터를 읽으려면 먼저 DBA부터 확인해야한다. 인덱스를 이용하는 경우 인덱스 ROWID를 이용, 테이블을 스캔할 때는 테이블 세그먼트 헤더에 저장된 익스텐트 맵을 이용한다.

[정의]
* 블록 : 데이터를 읽고 쓰는 단위
* 익스텐트 : 공간을 확장하는 단위, 연속된 블록 집합
* 세그먼트 : 데이터 저장공간이 필요한 오브젝트(테이블, 인덱스, 파티션, LOB 등)
* 테이블 스페이스 : 세그먼트를 담는 콘테이너
* 데이터 파일 : 디스크 상의 물리적인 OS 파일

### 1.3.3 블록단위I/O
DBMS가 데이터를 읽고 쓰는 단위가 '블록'이다. 데이터 I/O 단위가 블록이므로 특정 레코드 하나를 읽고 싶어도 해당 블록을 통째로 읽는다. 테이블뿐만 아니라 인덱스도 블록 단위로 데이터를 읽고 쓴다. 

### 1.3.4 시퀀셜 액세스 VS 랜덤 액세스
테이블 또는 인덱스 블록을 액세스하는 방식으로 시퀀셜 액세스와 랜덤 액세스, 두 가지가 있다. 

1) 시퀀셜 액세스 : 논리적 또는 물리적으로 연결된 순서에 따라 차례대로 블록을 읽는 방식이다. 인덱스 리프 블록은 앞뒤를 가리키는 주소값을 통해 논리적으로 서로 연결돼 있다. 이 주소값에 따라 앞 또는 뒤로 순차적으로 스캔하는 방식이 시퀀셜 액세스다. 오라클은 세그먼트에 할당된 익스텐트 목록을 세그먼트 헤더에 맵으로 관리한다. 익스텐트 맵은 각 인스텐트의 첫 번째 블록 주소 값을 갖는다. 읽어야할 익스텐트 목록을 익스텐트 맵에서 얻고, 각 익스텐트의 첫 번째 블록 뒤에 연속해서 저장된 블록을 순서대로 읽으면 그것이 곧 Full scan이다.
2) 랜덤 액세스 : 논리적, 물리적 순서에 따르지 않고, 레코드 하나를 읽기 위해 한 블록씩 접근하는 방식이다. 

### 1.3.4 논리적I/O VS 물리적I/O
__DB버퍼 캐시__ : SQL을 수행하는 과정에서 계속해서 데이터 블록을 읽는데, 자주 읽는 블록을 매번 디스크에서 읽는 것은 비효율적이다. 라이브러리 캐시가 SQL과 실행계획, DB저장형 함수/프로시저 등을 캐싱하는 코드 캐시라 한다면 DB 버퍼캐시는 '데이터 캐시'라고 할 수 있다. 디스크에서 어렵게 읽은 데이터 블록을 캐싱해 둠으로써 같은 블록에 대한 반복적인 I/O Call을 줄이는 데 목적이 있다.

서버 프로세스와 데이터파일 사이에 버퍼 캐시가 있으므로 데이터 블록을 읽을 땐 항상 버퍼캐시부터 탐색한다. 캐시에서 블록을 찾는다면 프로세스가 잠을 자지 않아도 되어 효율적이다. 

__논리적I/O VS 물리적I/O__ : 논리적 블록 I/O는 SQL문을 처리하는 과정에 메모리 __버퍼캐시__ 에서 발생한 총 블록 I/O를 말한다. 물리적 I/O는 __디스크__ 에서 발생한 총 블록 I/O를 말한다. SQL처리 중 읽어야할 블록을 버퍼캐시에서 찾지 못할 때만 디스크를 액세스하므로 논리적 블록 I/O 중 일부를 물리적으로 I/O한다.

메모리 I/O는 전기적 신호인데 반해 디스크I/O는 액세스 암을 통해 물리적 작용이 일어나므로 메모리 I/O에 비해 상당히 느리다.

SQL을 수행하려면 데이터가 담긴 블록을 읽어야 한다. SQL이 참조하는 테이블에 데이터를 입력하거나 삭제하지 않는 상황에서 조건절에 같은 변수 값을 입력하면 아무리 여러 번 실행해도 매번 읽는 블록 수는 같다. SQL을 수행하면서 읽은 총 블록 I/O가 논리적 I/O이다. 대부분 모든 블록은 DB 버퍼캐시를 경유해서 읽는다. 따라서 논리적 I/O횟수는 DB버퍼캐시에서 블록을 읽은 횟수와 일치한다.

DB버퍼캐시에서 블록을 찾지 못해 디스크에서 읽은 블록I/O가 물리적 I/O이다. 데이터 입력이나 삭제가 없어도 물리적I/O는 SQL을 실행할 때마다 다르다. 연속해서 실행하면 DB버퍼캐시에서 해당 테이블 블록의 점유율이 점점 높아져 실행시마다 I/O가 줄어든다. 한참 후에 다시 실행하면 반대로 물리적 I/O가 늘어나게되는데 이는 DB버퍼캐시가 다른 테이블 블록으로 채워지기 때문이다.

__버퍼캐시 히트율__ : 버퍼캐시의 효율을 측정하는 데 전통적으로 가장 많이 사용해 온 지표를 구하는 공식 'BCHR' 전체 블록 중에서 물리적인 디스크 I/O를 수반하지 않고 곧바로 메모리에서 찾은 비율을 나타낸다.

**BCHR 공식을 보면 물리적 I/O가 성능을 결정하지만 실제 성능을 향상하려면 물리적 I/O가 아닌 논리적 I/O를 줄여야 한다는 사실이다. 논리적I/O를 줄이려면 SQL을 튜닝해서 읽는 총 블록 개수를 줄이면 된다. 논리적 I/O는 항상 일정하게 발생하지만 SQL 튜닝을 통해 줄일 수 있는 통제 가능한 내생변수다.(물리적I/O는 시스템 상황에 의해 결정되는 통제 불가능한 외생변수)

BCHR이 SQL 성능을 좌우하지만, BCHR이 높다고 해서 효율적인 SQL을 의미하지는 않는다. 같은 블록을 비효율적으로 반복해서 읽는 경우 BCHR이 높아진다.