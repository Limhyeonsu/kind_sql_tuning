# SQL 옵티마이저
## 7.1 통계정보와 비용 계산 원리
### 7.1.1 선택도와 카디널리티
__선택도__ - 전체 레코드 중에서 조건절에 의해 선택되는 레코드 '비율'이고, = 조건으로 검색할 때 선택도 = 1 / NDV(컬럼 값 종류 개수)이다. __카디널리티__ - 전체 레코드 중에서 조건절에 의해 선택되는 레코드 '개수'이며 카디널리티 = 총 로우수 * 선택도 = 총 로우수 / NDV 공식으로 구한다. 

예) 상품 분류 컬럼에 '가전', '의류', '식음료', '생활용품' 4개의 값이 있는 경우 선택도는 4분의 1로 25%이다. 

옵티마이저는 카디널리티를 구하고, 그만큼 데이터를 액세스하는 데 드는 비용을 계산해서 테이블 액세스 방식, 조인 순서, 조인 방식 등을 결정한다. 이때 비용을 계산하는 출발점은 '선택도'이고, 선택도를 잘못 계산하면 카디널리티와 비용도 잘못 계산하고, 결과적으로도 비효율적인 액세스 방식과 조인 방식을 선택하게 된다.

### 7.1.2 통계정보
1) 테이블 통계 : 'DBMS_STATS.GATHER_TABLE_STATS' 명령어를 사용하여 통계정보를 볼 수 있다. 통계항목으로
* NUM_ROWS : 테이블에 저장된 총 레코드 개수
* BLOCKS : 테이블 블록 수 = '사용된' 익스텐트에 속한 총 블록 수
* AVG_ROW_LEN : 레코드당 평균 길이
* SAMPLE_SIZE : 샘플링한 레코드 수
* LAST_ANALYZED : 통계정보 수집일시

2) 인덱스 통계 : 'DBMS_STATS.GATHER_INDEX_STATS' 명령어 사용
* BLEVEL : 브랜치 레벨
* LEAF_BLOCKS : 인덱스 리프블록 총 개수
* NUM_ROWS : 인덱스에 저장된 레코드 개수
* DISTINCT_KEYS :인덱스 키 값의 조합으로 만들어지는 값의 종류 개수
* AVG_LEAF_BLOCKS_PER_KEY : 인덱스 키 값을 모두 = 조건으로 조회할 때 읽게 될 리프 블록 개수
* AVG_DATA_BLOCKS_PER_KEY : 인덱스 키 값을 모두 = 조건으로 조회할 때 읽게 될 테이블 블록 개수
* CLUSTERING_FACTOR : 인덱스 키 값 기준으로 테이블 데이터가 모여있는 정도

3) 컬럼 통계 : 테이블 통계 수집할 때 함께 수집된다.
* NUM_DISTINCT : 컬럼 값의 종류 개수
* DENSITY : = 조건으로 검색할 때의 선택도를 미리 구해놓은 값 (1/NUM_DISTINCT 값과 일치)
* AVG_COL_LEN : 컬럼 평균 길이
* LOW_VALUE : 최소 값
* HIGH_VALUE : 최대 값
* NUM_NULLS :값이 NULL인 레코드 수

__컬럼 히스토그램__ : 히스토그램은 컬럼 값 별로 데이터 비중 또는 빈도를 미리 계산해 놓은 통계정보다.

4) 시스템 통계 : 애플리케이션 및 하드웨어 성능 특성을 측정한 것으로 아래의 항목을 포함한다.
* CPU 속도
* 평균적인 SINGLE BLOCK I/O 속도
* 평균적인 MULTIBLOCK I/O 속도
* 평균적인 MULTIBLOCK I/O 개수
* I/O 서브시스템의 최대 처리량
* 병렬 SLAVE의 평균적인 처리량

시스템 사양뿐만 아니라 애플리케이션 특성 및 동시 트랜잭션 발생량에 따라서도 이들 성능 특성이 달라진다.

### 7.1.3 비용 계산 원리
    
    --인덱스 키 값을 모두 = 조건으로 검색할 때는 아래와 같이 인덱스 통계만으로 쉽게 비용을 계산할 수 있다.
    비용 = BLEVEL                       -- 인덱스 수직적 탐색 비용
         + AVG_LEAF_BLOCKS_PER_KEY      -- 인덱스 수평적 탐색 비용
         + AVG_DATA_BLOCKS_PER_KEY      -- 테이블 랜덤 액세스 비용

    --인덱스 키 앖이 모두 = 조건이 아닐때는 아래와 같이 컬럼 통계까지 활용한다.
    비용 = BLEVEL                                      -- 인덱스 수직적 탐색 비용
         + LEAF_BLOCKS X 유효 인덱스 선택도             -- 인덱스 수평적 탐색 비용
         + CLUSTERING_FACTOR X 유효 테이블 선택도       -- 테이블 랜덤 액세스 비용

유효 인덱스 선택도는 전체 인덱스 레코드 중 액세스 조건에 의해 선택될 것으로 예상되는 레코드 비중(%)을 의미하고, 유효 테이블 선택도는 전체 인덱스 레코드 중 인덱스 컬럼에 대한 모든 조건절에 의해 선택될 것으로 예상되는 레코드 비중(%)을 의미한다.

## 7.2 옵티마이저에 대한 이해
### 7.2.1 옵티마이저 종류
1) 비용기반 옵티마이저(CBO) - 실행계획 도출, 데이터 딕셔너리에 미리 수집해 둔 통계정보를 이용해 각 실행계획의 예상 비용을 산정하고 그중 가장 낮은 실행계획 하나를 선택하는 옵티마이저이다. (통계정보로 데이터량, 컬럼 값의 수, 컬럼 값 분포, 인덱스 높이, 클러스터링 팩터 등)
2) 규칙기반 옵티마이저(RBO) - 데이터 특성을 나타내는 통계정보를 전혀 활용하지 않고 단순한 규칙에만 의존하기 때문에 대량 데이터를 처리하는 데 부적합하다.

RBO 규칙 - 512p

### 7.2.2 옵티마이저 모드
비용기반 옵티마이저에는 최적화 목표를 설정하는 기능으로 세가지 모드가 있다.
* ALL ROWS : 전체 처리속도 최적화, 쿼리 결과집합 전체를 읽는 것을 전제로 시스템 리소스를 가장 적게 사용하는 실행계획을 선택 즉 전체 처리속도 최적화가 목표다.
* FIRST_ROWS : 최초 응답속도 최적화, 전체 결과집합 중 앞쪽 일부만 읽다가 멈추는 것을 전제로 응답속도가 가장 빠른 실행계획을 선택한다. 즉 최초 응답속도 최적화가 목표다.
* FIRST_ROWS_N : 최초 N건 응답속도 최적화, 사용자가 앞쪽 N개 로우만 읽고 멈추는 것을 전제로 응답속도가 가장 빠른 실행계획을 선택한다. N으로 지정할 수 있는 값은 1, 10, 100, 1000 네 가지다.

FIRST_ROWS는 사용자가 데이터를 어느 정도 읽다가 멈출지를 지정하지 않았으므로 정확한 비용산정이 어렵다. 따라서 FIRST_ROWS_N를 사용하도록 하자.

### 7.2.3 옵티마이저에 영향을 미치는 요소
1) SQL과 연산자 형태
2) 인덱스, IOT, 클러스터, 파티션, MV등 옵티마이징 팩터
3) 제약설정
4) 통계정보
5) 옵티마이저 힌트
6) 옵티마이저 관련 파라미터

### 7.2.4 옵티마이저의 한계
같은 SQL인데도 DBMS에 따라 버전에 따라 옵티마이저가 다른 실행계획을 생성한다는 사실을 통해 그 선택이 항상 최선이 아님을 짐작할 수 있다. 옵티마이저 행동에 가장 큰 영향을 미치는 통계정보를 필요한 만큼 충분히 확보하는 것부터가 불가능한 일이다. (정보가 많을수록 좋지만 정보를 수집하고 관리하는데 시간과 비용이 많이들기 때문)  또한 기본적으로 비용기반으로 작동하지만 내부적으로 여러 가정과 정해진 규칙을 이용해 기계적인 선택을 한다는 사실도 옵티마이저가 한계를 보이는 원인 중 하나다. 또 최적화에 허용되는 시간이 매우 짧은 것도 중요한 제약 중 하나다.

### 7.2.5 개발자의 역할
1) 필요한 최소 블록만 읽도록 쿼리 작성 : 데이터베이스 성능은 I/O 효율에 달려있으므로 동일한 레코드를 반복적으로 읽지 않고, 필요한 최소 블록만 읽도록 해야한다.
2) 최적의 옵티마이징 팩터 제공 : 옵티마이저는 주어진 환경에서 가장 빠른 처리경로를 찾아줄 뿐 없는 길을 스스로 만들어 내지는 못한다. 기능들을 활용할 수 있도록 물리적으로 DB를 구성하는 건 어디까지나 사람의 몫이다.
* 전략적인 인덱스 구성
* DBMS가 제공하는 다양한 기능 활용
* 옵티마이저 모드 설정
* 정확하고 안정적인 통계정보

3) 필요하다면 옵티마이저 힌트를 사용해 최적의 액세스 경로로 유도