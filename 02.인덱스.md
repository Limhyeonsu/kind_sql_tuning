# 인덱스 기본
## 2.1 인덱스 구조 및 탐색
### 2.1.1 미리보는 인덱스 튜닝
__데이터를 찾는 두 가지 방법__ : 1)테이블 전체를 스캔한다. 2)인덱스를 이용한다. 

__인덱스 튜닝의 두 가지 핵심요소__ : 인덱스는 큰 테이블에서 소량 데이터를 검색할 때 사용한다. 핵심 요소로는 1)인덱스 스캔과정에서 발생하는 비효율을 줄이는 것(인덱스 스캔 효율화 튜닝) 2)테이블 액세스 횟수를 줄이는 것(랜덤 액세스 최소화 튜닝)

둘 중 더 중요한 하나를 고르자면 랜덤 액세스 최소화 튜닝이다. 성능에 미치는 영향이 더 크기 때문이다. 데이터베이스 성능이 느린 이유는 디스크I/O때문이다. 읽어야할 데이터량이 많고, 그 과정에서 디스크I/O가 많이 발생할 때 느리다.

### 2.1.2 인덱스 구조
인덱스는 대용량 테이블에서 필요한 데이터만 빠르게 효율적으로 액세스하기 위해 사용하는 오브젝트다. 데이터베이스에서 인덱스 없이 데이터를 검색하려면 테이블을 처음부터 끝까지 모두 읽어야한다. 반면 인덱스를 사용하면 일부만 읽고 멈출 수 있다. 즉 범위스캔이 가능하다. 범위스캔이 가능한 이유는 인덱스가 __정렬__ 되어 있기 때문이다. DBMS는 일반적으로 B-Tree 인덱스를 사용한다. (루트, 브랜치, 리프로 구성됨) 리프 블록에 저장된 각 레코드는 키값 순으로 정렬돼 있을뿐 아니라 테이블 레코드를 가지키는 주소값, 즉 ROWID를 갖는다. 인덱스 키 값이 같으면 ROWID 순으로 정렬된다.

### 2.1.3 인덱스 수직적 탐색
정렬된 인덱스 레코드 중 조건을 만족하는 첫 번째 레코드를 찾는 과정이다. 즉 인덱스 스캔 시작지점을 찾는 과정이다.(조건을 만족하는 레코드를 찾는 과정이 아닌 조건을 만족하는 첫 번째 레코드를 찾는 과정임) 수직적 탐색은 루트 블록에서부터 시작하고, 루트를 포함해 브랜치 블록에 저장된 각 인덱스 레코드는 하위 블록에 대한 주소값을 갖는다.

### 2.1.4 인덱스 수평적 탐색
수직적 탐색을 통해 스캔 시작점을 찾았으면, 찾고자 하는 데이터가 더 안 나타날 때까지 인덱스 리프 블록을 수평적으로 스캔한다. 인덱스에서 본격적으로 데이터를 찾는 과정이다.

인덱스 리프블록끼리는 서로 앞뒤 블록에 대한 주소값을 갖는다. 즉 양방향 연결 리스트 구조이다. 인덱스를 수평적으로 탐색하는 이유는 1)조건절을 만족하는 데이터를 모두 찾기 위해서 2)ROWID를 얻기 위해서

### 2.1.5 결합 인덱스 구조와 탐색
두 개 이상의 컬럼을 결합해서 인덱스를 만들 수도 있다. 인덱스를 결합할 때 구성의 순서를 어떻게 해도 읽는 인덱스 블록 개수는 똑같다. 인덱스 선두 컬럼을 모두 = 조건으로 검색시 블록I/O 개수가 같으므로 성능도 똑같다. 

**B-Tree 인덱스에서 B는 Balanced의 약자로 이는 어떤 값으로 탐색하더라도 인덱스 루트에서 리프 블록에 도달하기까지 읽는 블록 수가 같음을 의미한다. 즉, 루트로부터 모든 리프 블록까지의 높이는 항상 같다.

## 2.2 인덱스 기본 사용법
### 2.2.1 인덱스를 사용한다는 것
색인에서 찾고자 하는 키워드를 찾을 때 찾고자 하는 키워드의 시작지점을 바로 찾아간다. 그 과정이 '수직적 탐색'에 해당한다. 이렇게 찾아갈 수 있는 이유는 색인이 가나다 순으로 정렬되어 있기 때문이다. 만약 중간에 어떤 단어를 포함하는 키워드를 찾고자 한다면 정렬되어 있다하더라도 가공한 값이나 중간값으로는 스캔 시작점을 찾을 수 없기 때문에 색인 전체를 훑어봐야한다.

데이터베이스에서도 마찬가지이다. 인덱스 컬럼을 가공하지 않아야 인덱스의 리프블록에서 시작점을 찾아 거기서부터 스캔하다가 중간에 멈추는 즉 리프블록 일부만 스캔하는 Index Range Scan을 의미한다. 인덱스 컬럼을 가공해도 인덱스를 사용할 수 있지만 스캔 시작점을 찾을 수 없고, 멈출수도 없어 리프 블록 전체를 스캔해야만 한다. 즉 일부가 아닌 전체를 스캔하는 Index Full Scan 방식으로 작동한다.

### 2.2.2 인덱스를 Range Scan 할 수 없는 이유
인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용할 수 없다. 그 이유는 인덱스 스캔 시작점을 찾을 수 없기 때문이다. Index Range Scan에서 Range는 범위를 의미한다. 즉 Index Range Scan은 인덱스에서 일정 범위를 스캔한다는 뜻이다. 일정 범위를 스캔하기 위해서는 시작지점과 끝지점이 있어야 한다.

ex1) WHERE 생년월일 '20070101' BETWEEN AND '20070131'  (가공X)

ex2) WHERE SUBSTR(생년월일, 5, 2) = '05'  (가공O)

ex3) WHERE 업체명 LIKE '%대한%' (Range Scan X)  / WHERE 업체명 LIKE '대한%'  (Range Scan O)

### 2.2.3 더 중요한 인덱스 사용 조건
조건절에서 인덱스를 가공하게 되면 인덱스를 정상적으로 사용할 수 없다. 인덱스를 사용하는데 더 중요한 조건이 인덱스를 여러개의 조합으로 구성하고 있는 경우의 선행조건을 어떤것으로 하느냐이다. ex)인덱스를 '소속팀 + 사원명 + 연령' 순으로 구성하는 경우 먼저 소속팀으로 정렬 후 사원명, 연령 순으로 정렬을 하기 때문에 WHERE 사원명 = '홍길동'을 하는 경우 소속팀별 홍길동을 찾아야해서 인덱스 리프 블록을 처음부터 끝까지 모두 스캔해야한다.

따라서 인덱스를 Range Scan하기 위해서는 __인덱스 선두 컬럼이 조건절에 있어야 한다__ 는 사실이다. 인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있으면 인덱스 Range Scan은 무조건 가능하다. 단, 인덱스를 Range Scan 한다고 해서 항상 성능이 좋은것은 아님

### 2.2.4 인덱스를 이용한 소트 연산 생략
인덱스를 범위스캔 할 수 있는 이유는 데이터가 정렬되어 있기 때문이다. 이 때문에 소트 연산 생량 효과도 부수적으로 얻게 된다. 따라서 인덱스를 잘 사용한다면 옵티마이저는 ORDER BY를 사용해도 정렬 연산을 따로 수행하지 않는다.

### 2.2.5 ORDER BY 절에서 컬럼 가공
인덱스 컬럼은 대개 조건절에서 사용하나 조건절이 아닌 ORDER BY, SELECT-LIST에서 컬럼을 가공해서 사용하는 경우에도 인덱스를 정상적으로 사용할 수 없는 경우도 종종있다.

    SELECT *
    FROM (
        SELECT TO_CAHR(A.주문번호, 'FM000000') AS 주문번호, A.업체번호, A.주문금액
        FROM 주문 A
        WHERE A.주문일자 = :dt
          AND A.주문번호 > NVL(:next_ord_no, 0)
        ORDER BY 주문번호
    )
    WHERE ROWNUM <=30

위 쿼리의 경우 실행계획을 보면 ORDER BY 연산이 나타난다 그 이유는 ORDER BY 절의 주문번호가 SELECT절에 있는 가공된 주문번호를 가리키고 있기 때문이다.

해결방법은 __ORDER BY A.주문번호__ 로 고쳐주면 된다. (SELECT 절의 주문번호가 아닌 테이블의 주문번호 컬럼으로 정렬할 수 있게)

### 2.2.6 SELECT-LIST에서 컬럼 가공
인덱스 컬럼의 최대값(MAX), 최소값(MIN)을 구하는 경우에도 옵티마이저는 정렬 연산을 수행하지 않는다. 

    SELECT NVL(MAX(TO_NUMBER(변경순번)), 0)  --정렬 연산 생략 불가
    SELECT NVL(TO_NUMBER(MAX(번경순번)),0)   --정렬 연산 생략 가능

### 2.2.7 자동 형변환
    SELECT * FROM 고객
    WHERE 생년월일 = 19821225
위 쿼리를 실행계획으로 보면 옵티마이저는 WHERE TO_NUMBER(생년월일) = 19821225 로 변환한다. 인덱스 컬럼이 가공되었기 때문에 인덱스를 범위 스캔할 수 없게 된다. 이는 생년월일 컬럼이 문자형인데 조건절의 비교값으로 숫자형을 넣었기 때문에 나타난 현상이다. __각 조건절에서 양쪽 값의 데이터 타입이 서로 다르면 값을 비교할 수 없다.__ 이 경우 ORACLE은 자동으로 형변환하여 처리해준다.

**오라클에서 숫자형과 문자형이 만나면 숫자형이 우선된다. 따라서 숫자형 컬럼 기준으로 문자형 컬럼을 변환한다. 날짜형과 문자형의 경우 날짜형이 우세, LIKE 연산의 경우 LIKE 자체가 문자열 비교연산자이므로 문자형 기준으로 숫자형 컬럼이 변환된다.

    --사용자가 계좌번호를 입력한 경우
    SELECT * FROM 거래
    WHERE 계좌번호 = :acnt_no
    AND 거래일자 BETWEEN :trd_dt1 AND :trd_dt2

    --사용자가 계좌번호를 입력하지 않은 경우
    SELECT * FROM 거래
    AND 거래일자 BETWEEN :trd_dt1 AND :trd_dt2

    --경우에 따라 위처럼 두개의 쿼리문이 필요한 경우가 있다. 이때 LIKE조건을 사용하여 하나로 처리할 수 있다.
    SELECT * FROM 거래
    WHERE 계좌번호 LIKE :act_no || '%'  --변수에 NULL 값이 들어가면 전체 검색됨
    AND 거래일자 BETWEEN :trd_dt1 AND :trd_dt2

    --단, LIKE, BETWEEN 조건을 같이 사용하게 되면 인덱스 스캔 효율이 안 좋아진다. 특히 계좌번호 컬럼이 숫자형일 때 주의가 필요

자동 형변환시 또 다른 문제점으로 숫자형 컬럼과 문자형 컬럼 비교시 문자형 컬럼이 숫자형 컬럼으로 자동 형변환 되는데 이때 문자형 컬럼에 숫자로 변환할 수 없는 문자가 포함되어 있다면 쿼리 수행시 에러가 발생한다. 따라서 자동 형변환 기능에 의존하지 말고, 인덱스 컬럼 기준으로 반대편 컬럼 또는 값을 정확히 형변환해 주어야 한다.

**TO_CHAR, TO_DATE, TO_NUMBER 같은 형변환 함수를 생략하는 것이 성능이 더 좋다고 생각할 수 있으나 SQL의 성능은 그런데서 결정되는 것이 아니라 __블록I/O를 줄일 수 있느냐 없느냐에서 결정__ 된다. 또 개발자가 형변환 함수를 생략해도 옵티마이저가 자동으로 생성한다..
 