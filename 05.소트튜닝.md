# 소트튜닝
## 5.1 소트 연산에 대한 이해
### 5.1.1 소트 수행 과정
소트는 기본적으로 PGA에 할당한 sort area에서 이루어진다. 메모리 공간인 sort area가 다 차면 디스크 Temp 테이블스페이스를 활용한다. 

* 메모리 소트 : 전체 데이터의 정렬 작업을 메모리 내에서 완료하는 것 'Internal Sort'
* 디스크 소트 : Sort Area 내에서 정렬을 완료하지 못해 디스크 공간까지 사용하는 경우 'External Sort'

소트 연산은 메모리 집약적일 뿐만 아니라 CPU 집약적이기도 하다. 처리할 데이터량이 많을 때는 디스크 I/O까지 발생하므로 쿼리 성능을 좌우하는 매우 중요한 요소다. 또 부분범위 처리를 불가능하게 함으로써 OLTP 환경에서 애플리케이션 성능을 저하시키는 주요인이 되기도 한다. 따라서 될 수 있으면 소트가 발생하지 않도록 SQL을 작성해야 하고, 소트가 불가피하다면 메모리내에서 수행을 완료할 수 있도록 해야 한다.

### 5.1.2 소트 오퍼레이션
__(1)Sort Aggregate__ : 전체 로우를 대상으로 집계를 수행할 때 나타난다. Sort라는 표현을 사용하지만 실제로 데이터를 정렬하진 않는다.

__(2)Sort Order By__ : 데이터를 정렬할 때 나타남

__(3)Sort Group By__ : 소팅 알고리즘을 사용해 그룹별 집계를 수행할 때 나타난다. (Hash Group By는 해싱 알고리즘을 사용한 방식으로 Group by 절 뒤에 Order By 절을 명시하지 않으면 대부분 Hash Group By 방식으로 처리함)

__(4)Sort Unique__ : 서브쿼리 Unnesting된 서브 쿼리가 M쪽 집합이면 메인 쿼리와 조인하기 전에 중복 레코드부터 제거해야한다. 이때 Sort Unique 오퍼레이션이 나타난다. 만약 PK/Unique 제약 또는 Unique 인덱스를 통해 Unnesting된 서브쿼리의 유일성이 보장된다면 Sort Unique 오퍼레이션은 생략된다. 또 집합연산자, distinct 연산자 사용시에도 Sort Unique 오퍼레이션이 나타난다.

__(5)Sort Join__ : 소트 머지 조인을 수행할 때 나타남

__(6)Window Sort__ : 윈도우 함수를 수행할 때 나타남
 
## 5.2 소트가 발생하지 않도록 SQL 작성
### Union vs Union All
Union을 사용하면 옵티마이저는 두 집합 간 중복을 제거하려고 소트 작업을 수행한다. 반면 Union All은 중복을 확인하지 않고 두 집합을 단순히 결합하므로 소트 작업을 수행하지 않는다 따라서 될 수 이씅면 Union All을 사용해야한다.

### Exists 활용
중복 레코드 제거시 Distinct 연산자를 종종 사용하는데 이 연산자는 조건에 해당하는 데이터를 모두 읽어서 중복을 제거해야한다. 따라서 부분범위 처리는 불가능 하고 데이터를 읽는 과정에 많은 I/O가 발생한다. Distinct 대신에 Exists를 사용하면 데이터가 한건이라도 존재하는지만 확인하기 때문에 부분범위 처리도 가능하다. (Minus 연산자 대신 Not Exists)

### 조인 방식 변경
조인방식에 따라서도 소트 연산을 생략할 수 있기 때문에 조인 방식도 잘 선택해주어야 한다. 조건을 만족하는 데이터가 많고, 부분범위 처리가 가능한 상황에서 NL조인하도록 하면 소트 연산을 생략할 수 있어 성능 개선 효과를 얻을 수 있다. 또 정렬 기준이 조인 키 컬럼이면 소트 머지조인도 Sort Order By 연산을 생략할 수 있다.

## 5.3 인덱스를 이용한 소트 연산 생략
### 5.3.1 Sort Order By 생략
### 5.3.2 Top N 쿼리
Top N 쿼리는 전체 결과집합 중 상위 N개 레코드만 선택하는 쿼리다. Top N 쿼리를 사용하고 조건절에 인덱스 선두 컬럼을 이용한다면 옵티마이저는 소트 연산을 생략하고, 인덱스를 스캔하다가 지정한 레코드 수만큼만 읽고 바로 멈춘다. 이 때 실행계획을 보면 COUNT(STOPKEY)가 생기는데 이는 조건절에 부합하는 레코드가 아무리 많아도 그 중 ROWNUM으로 지정한 건수만큼 결과 레코드를 얻으면 거기서 바로 멈춘다는 뜻이다.

3-Tier 환경에서 대량의 결과 집합을 조회할 때 페이징 처리 기법을 활용한다. 부분범위 처리를 활용하기 위해서는 부분범위 처리 가능하도록 SQL을 작성해야하는데 이는 인덱스 사용이 가능하도록 조건절을 구사하고, 조인은 NL 조인 위주로 처리, Order By 절이 있어도 소트 연산을 생략할 수 있도록 인덱스를 구성해주는 것을 의미한다.

페이징 처리시 ROWNUM 조건절이 불필요해 보여 ROWNUM 조건을 제거하고 사용하는 경우가 있는데  페이징 처리시 ROWNUM은 단순한 조건절이 아니라 Top N StopKey 알고리즘을 작동하게 하는 열쇠다.

### 5.3.3 최소값/최대값 구하기
최소값, 최대값 구하는 SQL 실행계획을 보면 Sort Aggregate 오퍼레이션이 나타난다. Sort Aggregate은 전체 데이터를 정렬하진 않지만 전체 데이터를 읽으면서 값을 비교한다. 인덱스는 정렬돼 있으므로 이를 이용하면 전체 데이터를 읽지 않고도 최소, 최대값을 쉽게 찾을 수 있다.

인덱스를 이용해 최소, 최대값을 구하려면 조건절 컬럼과 MIN/MAX 함수 인자 컬럼이 모두 인덱스에 포함돼 있어야 한다. 즉 테이블 액세스가 발생하지 않아야한다.

362~364p

Top N 쿼리를 이용해 최소, 최대값을 쉽게 구할 수 있다. Top N Stopkey 알고리즘은 모든 컬럼이 인덱스에 포함돼 있지 않아도 잘 작동한다. 인라인 뷰를 사용하므로 쿼리가 더 복잡하긴 하지만 성능 측면에서는 MIN, MAX 쿼리보다 낫다.

    SELECT *
    FROM (
        SELECT SAL
        FROM EMP
        WHERE DEPTNO = 30
        AND MGR = 7698
        ORDER BY SAL DESC
    )
    WHERE ROWNUM <= 1;

### 5.3.4 이력 조회
이력 데이터를 조회할 때 'First Row Stopkey', 'Top N Stopkey' 알고리즘이 작동할 수 있게 인덱스 설계 및 SQL 구현하여야 한다.

INDEX_DESC 힌트 활용 : 인덱스를 역순으로 읽도록 index_desc 힌트를 사용하고, 첫 번째 레코드에서 바로 멈추도록 rownum <= 1 조건절을 사용하면 성능은 확실히 좋다. 하지만 인덱스 구성이 완벽해야만 쿼리가 잘 동작한다.(인덱스 구성이 바뀌게 되면 결과 집합에 문제가 생길 수 있음)

### 5.3.5 Sort Group by 생략
379~380p