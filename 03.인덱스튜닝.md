# 인덱스 튜닝
## 3.1 테이블 액세스 최소화
### 3.1.1 테이블 랜덤 액세스
인덱스를 스캔하는 이유는 ROWID를 얻으려는데 있다. ROWID는 물리적 주소 같지만 논리적 주소에 더 가깝다. ROWID는 디스크 상에서 테이블 레코드를 찾아가기 위한 위치 정보를 담는다. 프로그래밍에서 말하는 포인터가 아니며, 테이블 레코드와 물리적으로 직접 연결된 구조는 더더욱 아니다.

__메인 메모리 DB와 비교__ : 메인 메모리 DB는 데이터를 모두 메모리에 로드해 놓고 메모리를 통해서만 I/O를 수행하는 DB이다. 메인 메모리 DB에서 인덱스는 오라클처럼 디스크상의 주소를 갖는 게 아니라 메모리상의 주소정보, 즉 포인터를 갖는다. 오라클은 테이블 블록이 수시로 버퍼캐시에서 밀려났다가 다시 캐싱되며 그때마다 다른 공간에 캐싱되기 때문에 인덱스에서 포인터로 직접 연결할 수 없는 구조다. 포인터가 아닌 디스크 주소 정보를 이용해 해시 알고리즘으로 버퍼 블록을 찾아간다.

__I/O 메커니즘__ : I/O성능을 높이려면 버퍼캐시를 활용해야한다. ROWID가 가리키는 테이블 블록을 버퍼캐시에서 먼저 찾아보고, 못 찾을 때만 디스크에서 블록을 읽는다. (버퍼캐시에 적재한 후) 모든 데이터가 캐싱돼 있더라도 테이블 레코드를 찾기 위해 매번 DBA 해싱과 래치 획득 과정을 반복해야한다. 이처럼 인덱스 ROWID를 이용한 테이블 액세스는 고비용 구조이다.

### 3.1.2 인덱스 클러스터링 팩터
클러스터링 팩터는 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미한다. 클러스터링 팩터가 좋은 컬럼에 생성한 인덱스는 검색 효율이 매우 좋다. ex)거주지역 = '제주'에 해당하는 고객 데이터가 물리적으로 근접해있으면 흩어져 있을 때보다 데이터를 찾는 속도가 빠르다.

### 3.1.3. 인덱스 손익분기점
인덱스를 이용하는 경우 읽어야 할 데이터가 일정량을 넘는 순간, 테이블 전체를 스캔하는 것보다 오히려 느려진다. Table Full Scan보다 느려지는 지점을 흔히 인덱스 손익분기점이라고 부른다. 이처럼 인덱스를 이용한 테이블 액세스가 Table Full Scan보다 더 느려지는 핵심 요인은

* Table Full Scan은 시퀀셜 액세스인 반면, 인덱스 ROWID를 이용한 테이블 액세스는 랜덤 액세스 방식이다.
* Table Full Scan은 Multiblock I/O인 반면, 인덱스 ROWID를 이용한 테이블 액세스는 Single Block I/O 방식이다.

__온라인 프로그램 튜닝 VS 배치 프로그램 튜닝__ : 온라인 프로그램은 보통 소량 데이터를 읽고 갱신하므로 인덱스를 효과적으로 활용하는 것이 무엇보다 중요하다. 조인도 대부분 NL방식을 사용한다. 배치 프로그램은 항상 전체범위 처리 기준으로 튜닝해야한다. 즉 전체를 빠르게 처리하는 것을 목표로 삼아야한다. 대량 데이터를 빠르게 처리하기 위해서는 인덱스와 NL조인보다 Full Scan과 해시 조인이 유리하다.

하지만 초대용량 테이블을 Full Scan 하면 상당히 오래 기다려야하고 시스템에 주는 부담도 적지 않다. 따라서 배치 프로그램에서는 파티션 활용 전략이 매우 중요한 튜닝 요소이고, 병렬처리 까지 더할 수 있으면 금상첨화다.