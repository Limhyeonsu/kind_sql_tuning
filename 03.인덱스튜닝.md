# 인덱스 튜닝
## 3.1 테이블 액세스 최소화
### 3.1.1 테이블 랜덤 액세스
인덱스를 스캔하는 이유는 ROWID를 얻으려는데 있다. ROWID는 물리적 주소 같지만 논리적 주소에 더 가깝다. ROWID는 디스크 상에서 테이블 레코드를 찾아가기 위한 위치 정보를 담는다. 프로그래밍에서 말하는 포인터가 아니며, 테이블 레코드와 물리적으로 직접 연결된 구조는 더더욱 아니다.

__메인 메모리 DB와 비교__ : 메인 메모리 DB는 데이터를 모두 메모리에 로드해 놓고 메모리를 통해서만 I/O를 수행하는 DB이다. 메인 메모리 DB에서 인덱스는 오라클처럼 디스크상의 주소를 갖는 게 아니라 메모리상의 주소정보, 즉 포인터를 갖는다. 오라클은 테이블 블록이 수시로 버퍼캐시에서 밀려났다가 다시 캐싱되며 그때마다 다른 공간에 캐싱되기 때문에 인덱스에서 포인터로 직접 연결할 수 없는 구조다. 포인터가 아닌 디스크 주소 정보를 이용해 해시 알고리즘으로 버퍼 블록을 찾아간다.

__I/O 메커니즘__ : I/O성능을 높이려면 버퍼캐시를 활용해야한다. ROWID가 가리키는 테이블 블록을 버퍼캐시에서 먼저 찾아보고, 못 찾을 때만 디스크에서 블록을 읽는다. (버퍼캐시에 적재한 후) 모든 데이터가 캐싱돼 있더라도 테이블 레코드를 찾기 위해 매번 DBA 해싱과 래치 획득 과정을 반복해야한다. 이처럼 인덱스 ROWID를 이용한 테이블 액세스는 고비용 구조이다.

### 3.1.2 인덱스 클러스터링 팩터
클러스터링 팩터는 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미한다. 클러스터링 팩터가 좋은 컬럼에 생성한 인덱스는 검색 효율이 매우 좋다. ex)거주지역 = '제주'에 해당하는 고객 데이터가 물리적으로 근접해있으면 흩어져 있을 때보다 데이터를 찾는 속도가 빠르다.

### 3.1.3. 인덱스 손익분기점
인덱스를 이용하는 경우 읽어야 할 데이터가 일정량을 넘는 순간, 테이블 전체를 스캔하는 것보다 오히려 느려진다. Table Full Scan보다 느려지는 지점을 흔히 인덱스 손익분기점이라고 부른다. 이처럼 인덱스를 이용한 테이블 액세스가 Table Full Scan보다 더 느려지는 핵심 요인은

* Table Full Scan은 시퀀셜 액세스인 반면, 인덱스 ROWID를 이용한 테이블 액세스는 랜덤 액세스 방식이다.
* Table Full Scan은 Multiblock I/O인 반면, 인덱스 ROWID를 이용한 테이블 액세스는 Single Block I/O 방식이다.

__온라인 프로그램 튜닝 VS 배치 프로그램 튜닝__ : 온라인 프로그램은 보통 소량 데이터를 읽고 갱신하므로 인덱스를 효과적으로 활용하는 것이 무엇보다 중요하다. 조인도 대부분 NL방식을 사용한다. 배치 프로그램은 항상 전체범위 처리 기준으로 튜닝해야한다. 즉 전체를 빠르게 처리하는 것을 목표로 삼아야한다. 대량 데이터를 빠르게 처리하기 위해서는 인덱스와 NL조인보다 Full Scan과 해시 조인이 유리하다.

하지만 초대용량 테이블을 Full Scan 하면 상당히 오래 기다려야하고 시스템에 주는 부담도 적지 않다. 따라서 배치 프로그램에서는 파티션 활용 전략이 매우 중요한 튜닝 요소이고, 병렬처리 까지 더할 수 있으면 금상첨화다.

### 3.1.4 인덱스 컬럼추가
테이블 액세스 최소화를 위해 가장 일반적으로 사용하는 튜닝 기법은 인덱스에 컬럼을 추가하는 것이다.

    //ex) pk이외에 DEPTNO + JOB 순으로 구성한 EMP_X01 인덱스 하나만 있는 상태일때
    SELECT /*+ index(emp emp_x01) */ *
    FROM EMP
    WHERE DEPTNO = 30
    AND SAL >= 2000

위 경우 인덱스가 DEPTNO + SAL 순으로 변경하면 좋겠지만 실 운영 환경에서 인덱스 구성을 변경하기 쉽지 않다. (기존 인데스를 사용할 수 있기 때문) 이럴때 기존 인덱스에 SAL 컬럼을 추가하는 것만으로도 큰 효과를 얻을 수 있다. 인덱스 스캔량은 줄지 않았지만 테이블 랜덤 액세스 횟수를 줄여주기 때문이다.

### 3.1.5 인덱스만 읽고 처리
테이블 랜덤 액세스가 아무리 많아도 필터 조건에 의해 버려지는 레코드가 거의 없다면 거기에 비효율은 없다.

    SELECT 부서번호, SUM( 수량)
    FROM 판매집계
    WHERE 부서번호 LIKE '12%'
    GROUP BY 부서번호;

위 쿼리의 경우 부서번호 단일 컬럼으로 구성된 인덱스를 사용한다면 비효율은 없다. 인덱스에서 부서번호 LIKE 조건에 해당하는 데이터를 찾고 테이블을 액세스한 후에 버리는 데이터가 하나도 없기 때문이다. 하지만 비효율이 없더라도 인덱스 스캔 과정에서 얻은 데이터가 많다면 그만큼 테이블 랜덤 액세스가 많이 발생하므로 성능이 느릴 수 밖에 없다.

위 같은 경우 쿼리나 인덱스의 문제가 아닌 절대 일량이 많아서 느린거니 어쩔 수 없다. 반드시 성능을 개선해야 한다면, 쿼리에 사용된 컬럼을 모두 인덱스에 추가해서 테이블 액세스가 아예 발생하지 않게 하는 방법을 고려해 볼 수 있다.

**인덱스만 읽어서 처리하는 쿼리를 'Covered 쿼리' 그 쿼리에 사용한 인덱스를 'Covered 인덱스'라 부른다.

### 3.1.6 인덱스 구조 테이블
랜덤 액세스가 아예 발생하지 않도록 테이블을 인덱스 구조로 생성하는 방식을 oracle에서는 IOT(Index-Organized Table)이라 부르고, MS-SQL Server는 클러스터형 인덱스라고 부른다.

테이블을 찾아가기 위한 ROWID를 갖는 일반 인덱스와 달리 IOT는 그 자리에 테이블 데이터를 갖는다. IOT는 인위적으로 클러스터링 팩터를 좋게 만드는 방법 중 하나다. 같은 값을 가진 레코드들이 100% 정렬된 상태로 모여 있으므로 랜덤 액세스가 아닌 시퀀셜 방식으로 데이터를 액세스한다. 이 때문에 BETWEEN이나 부등호 조건으로 넓은 범위를 읽을 때 유리하다.

### 3.1.7 클러스터 테이블
1) __인덱스 클러스터 테이블__ : 클러스터 키 값이 같은 레코드를 한 블록에 모아서 저장하는 구조이다. 한 블록에 모두 담을 수 없는 경우 새로운 블록을 할당해서 클러스터 체인으로 연결한다. 이름 때문에 클러스터형 인덱스와 같다고 생각할 수 있으나 클러스터형 인덱스는 IOT와 가깝다. 오라클 클러스터는 키 값이 같은 데이터를 같은 공간에 저장해 둘 뿐 IOT나 SQL Server의 클러스터형 인덱스처럼 정렬하지는 않는다.
클러스터 인덱스는 테이블 레코드와 1:M 관계를 갖는다. 따라서 클러스터 인덱스의 키 값은 항상 유니크한다. 클러스터 인덱스를 스캔하면서 값을 찾을 때는 랜덤 액세스가 값 하나당 한 번씩 밖에 발생하지 않는다. 클러스터에 도달해서는 시퀀셜 방식으로 스캔하기 때문에 넓은 범위를 읽더라도 비효율이 없다는 게 핵심 원리다.

2) __해시 클러스터 테이블__ : 인덱스를 사용하지 않고 해시 알고리즘을 사용해 클러스터를 찾아간다.

## 3.2 부분범위 처리 활용
### 3.2.1 부분범위 처리
DBMS가 클라이언트에게 데이터를 전송할 때 일정량씩 나눠서 전송한다. 전체 결과 집합 중 아직 전송하지 않은 분량이 많이 남아있어도 서버 프로세스는 클라이언트로부터 추가 Fetch Call을 받기 전까지 그대로 멈춰서서 기다린다. 

이처럼 쿼리 결과집합을 쉼 없이 연속적으로 전송하지 않고 사용자로부터 Fetch Call이 있을 때마다 일정량씩 나누어 전송하는 것을 이른바 '부분범위 처리'라고 한다.

정렬조건이 있는 경우 부분범위 처리를 어떻게 할까? DB서버는 모든 데이터를 다 읽어 created 순으로 정렬을 마치고서야 클라이언트에게 데이터 전송을 시작할 수 있다. (전체범위처리) created 컬럼이 선두인 인덱스가 있으면, 부분범위 처리가 가능하다. 인덱스는 항상 정렬된 상태를 유지하므로 전체 데이터를 정렬하지 않고도 정렬된 상태의 결과집합을 바로 전송할 수 있기 때문이다.

### 3.2.2 부분범위 처리 구현
165p

### 3.2.3 OLTP환경에서 부분범위 처리에 의한 성능개선 원리
OLTP는 온라인 트랜잭션을 처리하는 시스템을 말한다. 온라인 트랜잭션은 일반적으로 소량 데이터를 읽고 갱신한다. 만약 OLTP성 업무에서 쿼리 결과 집합이 아주 많을 때 사용자가 모든 데이터를 일일이 다 확인하지는 않는다. 특정한 정렬 순서로 상위 일부 데이터만 확인한다. (예. 게시판 조회 등 주로 목록 조회)

    SELECT 게시글ID, 제목, 작성자, 등록일시
    FROM 게시판
    WHERE 게시판구분코드 = 'A'
    ORDER BY 등록일시 DESC

위 쿼리에서 인덱스 선두 컬럼을 게시판구분코드 + 등록일시 순으로 구성하면 소트 연산을 생략할 수 있어 게시판구분코드='A' 조건을 만족하는 전체 로우를 읽지 않고도 바로 결과집합 출력을 시작할 수 있다.  

__배치I/O__ : 배치I/O는 읽는 블록마다 건건이 I/O Call을 발생시키는 비효율을 줄이기 위해 고안한 기능이다.  인덱스를 이용해 테이블을 액세스하다가 버퍼 캐시에서 블록을 찾지 못하면 일반적으로 디스크 블록을 바로 읽는데, 이 기능이 작동하면 테이블 블록에 대한 디스크 I/O Call을 미뤘다가 읽을 블록이 일정량 쌓이면 한꺼번에 처리한다.

배치I/O 기능이 작동하면 인덱스를 이용해서 출력하는 데이터 정렬 순서가 매번 다를 수 있다. 옵티마이저는 인덱스로 소트 연산을 생략할 수 없거나 SQL에 ORDER BY가 없으면, 랜덤 I/O 성능을 향상하는 배치I/O를 선택한다. 따라서 인덱스의 정렬순서를 믿고 ORDER BY를 생략하는 개발 패턴은 사용하지 않아야 한다.
 
## 3.3 인덱스 스캔 효율화
### 3.3.1 인덱스 탐색
173~179p

### 3.3.2 인덱스 스캔 효율성
인덱스 스캔을 통해 얻는 결과 건수는 같은데 인덱스 리프 블록에서 스캔하는 레코드 개수에 차이가 생기는 이유는 인덱스 선행 컬럼이 조건절에 없기 때문이다. (인덱스 선행 컬럼이 조건절에 없거나 '=' 조건이 아니면 인덱스 스캔 과정에 비효율이 발생한다.)

### 3.3.3 액세스 조건과 필터 조건
인덱스를 스캔하는 단계에서 처리하는 조건절은 액세스 조건과 필터 조건으로 나뉜다. __인덱스 액세스 조건__ 은 인덱스 스캔범위를 결정하는 조건절이다. 인덱스 수직적 탐색을 통해 스캔 시작점을 결정하는 데 영향을 미치고, 인덱스 리프 블록을 스캔하다가 어디서 멈출지를 결정하는 데 영향을 미치는 조건절이다. __인덱스 필터 조건__ 은 테이블로 액세스할지를 결정하는 조건절이다. 인덱스를 이용하든, 테이블을 Full Scan하든, 테이블 액세스 단계에서 처리되는 조건절은 모두 필터 조건이다. __테이블 필터조건__ 은 쿼리 수행 다음 단계로 전달하거나 최종 결과집합에 포함할지를 결정한다.

### 3.3.4 비교연산자 종류와 컬럼 순서에 따른 군집성
테이블과 달리 인덱스에는 같은 값을 갖는 레코드들이 서로 군집해 있다. 같은 값을 찾을 때 = 연산자를 사용하므로 인덱스 컬럼을 앞쪽부터 누락없이 = 연산자로 조회하면 조건절을 만족하는 레코드는 모두 모여있다. =연산자가 아닌 범위 검색 조건을 넣은 경우 선행 컬럼이 = 조건인 상태에서 첫 번째 나타나는 범위검색 조건까지만 만족하는 인덱스 레코드는 모두 연속해서 모여있지만, 그 이하 조건까지 만족하는 레코드는 비교 연산자 종류에 상관없이 흩어진다.

인덱스 스캔 범위를 결정하는 조건절이 인덱스 액세스 조건이다. 선행 컬럼이 모두 = 조건인 상태에서 첫 번째 나타나는 범위 검색 조건이 인덱스 스캔 범위를 결정한다. 그리고 나머지 인덱스 컬럼 조건은 인덱스 필터 조건이다.  __**액세스 조건이 많을수록 빠르다__

### 3.3.5 인덱스 선행 컬럼이 등치 조건이 아닐때 생기는 비효율
인덱스 컬럼을 조건절에 모두 등치 조건으로 사용할 때 가장 좋다. (조건을 만족하는 레코드가 모두 한데 모여 있기 때문), 등치 조건이 아닌 경우 나머지 조건을 만족하는 레코드들이 뿔뿔이 흩어져 있게 된다. 따라서 조건을 만족하지 않는 레코드까지 스캔하고서 버리는 비효율이 생긴다.

### 3.3.6 BETWEEN을 IN-List로 전환
BETWEEN을 IN-List로 전환하게 되면 인덱스의 수직적 탐색이 각각 발생한다. (IN은 쪼개서 날림) ex)인터넷 매물 IN ('1','2','3')   ==> 인터넷 매물 = 1 , 인터넷 매물 = 2, 인터넷 매물 = 3 으로 세번 탐색

IN-List 개수만큼 UNION ALL 브랜치가 생성되고 각 브랜치마다 모든 컬럼을 = 조건으로 검색하므로 Between을 사용할 때와 같은 비효율이 사라진다. 

주의점) IN-List로 전환시 IN-List의 개수가 많지 않아야한다. IN-List의 개수가 많으면 수직적 탐색이 많이 발생하여 브랜치 블록을 반복 탐색하는 비효율이 더 클 수 있다. 또 인덱스 스캔 과정에 선택되는 레코드들이 서로 멀리 떨어져 있을 때만 유용하다.
 
### 3.3.7. Index Skip Scan활용
(200~202p)BETWEEN 조건을 IN-List 조건으로 변환하지 않고도 같은 효과를 얻을 수 있는 방법이 있다. Index Skip Scan을 활용하는 것이다. 이는 선두 컬럼이 BETWEEN이어서
나머지 검색 조건을 만족하는 데이터들이 서로 멀리 떨어져 있을때 위력을 나타낸다.

### 3.3.8 IN 조건은 '='인가
    -- 인덱스를 상품ID + 고객번호 순으로 생성시
    SELECT *
    FROM 고객별가입상품
    WHERE 고객번호 = :cust_no
    AND 상품ID IN ('NH00037', 'NH00041', 'NH00050')

    SELECT *
    FROM 고객별가입상품
    WHERE 고객번호 = :cust_no
    AND 상품ID = 'NH00037'
    UNION ALL
    SELECT *
    FROM 고객별가입상품
    WHERE 고객번호 = :cust_no
    AND 상품ID = 'NH00041'
    UNION ALL
    SELECT *
    FROM 고객별가입상품
    WHERE 고객번호 = :cust_no
    AND 상품ID = 'NH00050'

위 쿼리에서는 같은 상품은 고객번호 순으로 정렬된 상태로 하나의 리프블록에 저장된다. 반면 고객번호 기준으로는 같은 고객번호가 상품ID별로 뿔뿔히 흩어지게 된다. 이처럼 고객번호와 상품ID 모두 인덱스 액세스 조건으로 사용되어 인덱스를 수직적으로 세 번 탐색한다. 

반대로 인덱스를 고객번호 + 상품ID 순으로 생성하면 고객은 상품ID 순으로 정렬된 상태로 같은 리프 블록에 저장된다. 같은 고객은 한 블록에 모두 모여있으므로 블록 I/O는 수직적 탐색 과정을 포함해 총 3~4개만 발생한다.

IN조건은 '=' 이 아니다. IN 조건이 '='이 되려면 IN-List Iterator 방식으로 풀려야만 한다. 그렇지 않으면 IN 조건은 필터 조건이다. IN-List Iterator 방식으로 푸는것이 항상 효과적이지는 않다.

IN-List를 액세스 조건 또는 필터 조건으로 유도하는 방법으로 힌트를 사용하는 방법이 있다. num_index_keys 힌트의 세번째 인자는 인덱스의 몇 번째 컬럼까지만 액세스 조건으로 사용하라는 의미이다.

    --1) 힌트를 사용하는 방법
    select /*+ num_index_keys(a 고객별가입상품_X1 1) */ *
    from 고객별가입상품 a
    where 고객번호 = :cust_no
    and 상품ID in ('NH00037', 'NH00041', 'NH00050')

    --2) 인덱스 컬럼을 가공하는 방법
    select *
    from 고객별가입상품 a
    where 고객번호 = :cust_no
    and RTRIM(상품ID) in ('NH00037', 'NH00041', 'NH00050')

    select *
    from 고객별가입상품 a
    where 고객번호 = :cust_no
    and 상품ID || '' in ('NH00037', 'NH00041', 'NH00050')

### 3.3.9 BETWEEN 과 LIKE 스캔범위 비교
    select * from 월별고객별판매집계
    where 판매월 like '2009%'
    and 판매구분 = 'B'

    select * from 월별고객별판매집계
    where 판매월 between '200901' and '200912'
    and 판매구분 = 'B'

between, like 모두 범위 조건으로 비효율 원리가 똑같이 적용되나 데이터 분포와 조건절 값에 따라 인덱스 스캔량이 서로 다를 수 있다. 둘 중 하나를 골라야 한다면 LIKE보다는 BETWEEN을 사용하는 게 낫다. between을 사용하는 경우 판매월 ='200901', 판매구분 = 'B'인 첫 번째 레코드에서 스캔을 시작하나, like의 경우 판매월 = '200901'인 첫번째 레코드에서 스캔을 시작한다. '200900'이 있을 수 있으므로 마로 판매구분 = 'B'로 갈 수 없다. 

### 3.3.10 범위검색 조건을 남용할 때 생기는 비효율
211~214p

### 3.3.11 다양한 옵션 조건 처리 방식의 장단점 비교
__OR조건 활용__ : 인덱스 선두 컬럼에 대한 옵션 조건에 OR조건을 사용해선 안 된다.  인덱스에 포함되지 않은 컬럼에 대한 옵션 조건은 테이블에서 필터링할 수 밖에 없으므로 그럴 때는 OR 조건을 사용해도 무방하다.

정리)

* 인덱스 액세스 조건으로 사용불가
* 인덱스 필터 조건으로 사용불가
* 테이블 필터 조건으로만 사용가능
* 단, 인덱스 구성 컬럼 중 하나 이상이 not null 컬럼이면 인덱스 필터 조건으로 사용 가능

__LIKE/BETWEEN 조건 활용__ : 필수 조건 컬럼을 인덱스 선두에 두고 액세스 조건으로 사용하면, LIKE/BETWEEN이 인덱스 필터 조건이어도 충분히 좋은 성능을 낼 수 있다. 필수 조건이 '='이면 옵션 조건까지도 인덱스 조건이므로 최적의 성능을 낼 수 있다.

	select * from 상품
	where 상품명 = :prd_nm  --필수조건
	and 상품분류코드 like :prd_cls_cd || '%' --옵션조건

1. 인덱스 선투컬럼에 대한 옵션 조건을 LIKE/BETWEEN 연산자로 처리하는 것은 금물
2. NULL허용 컬럼에 대한 옵션 조건을 LIKE/BETWEEN 연산자로 처리하는 것은 금물
3. 숫자형이면서 인덱스 액세스 조건으로도 사용 가능한 컬럼에 대한 옵션 조건 처리는 LIKE 방식을 사용해선 안 된다.(숫자형인 경우 자동 형변환이 일어나 필터 조건으로 사용된다.)
4. LIKE를 옵션 조건에 사용할 때는 컬럼 값 길이가 고정적이어야 한다. ex)김훈을 찾으려는데 김훈남이 같이 조회될 수 있음 따라서 가변길이일 땐 변수 값 길이가 같은 레코드만 조회하도록 한다.

__UNION ALL 활용__ 

    select * from 거래
    where :cust_id is null
    and 거래일자 between :dt1 and :dt2
    union all
    select * from 거래
    where :cust_id is not null
    and 고객id = :cust_id
    and 거래일자 between :dt1 and :dt2

위 쿼리는 :cust_id를 입력하든 안 하든 인덱스를 가장 최적으로 사용한다. (옵션 조건 컬럼도 인덱스 액세스 조건으로 사용함)

__NVL/DECODE 함수 활용__
NVL이나 DECODE 함수를 사용하면 OR Expansion 쿼리 변환이 일어난다. 이 함수를 사용했을 때 가장 큰 장점은 옵션 조건 컬럼을 인덱스 액세스 조건으로 사용할 수 있다는데 있다. UNION ALL보다 단순하면서 같은 성능을 낸다. 단점으로는 LIKE 패턴처럼 NULL 허용 컬럼에 사용할 수 없다. 그리고 함수를 여러개 사용시 그중 변별력이 가장 좋은 컬럼 기준으로 한 번만 OR Expansion이 일어나므로 OR Expansion 기준으로 선택되지 않으면 인덱스 구성 컬럼이어도 모두 필터 조건으로 처리된다.

### 3.3.12 함수호출부하 해소를 위한 인덱스 구성
__PL/SQL 함수의 성능적 특성__ : PL/SQL 사용자 정의 함수는 일반적으로 생각하는 것보다 매우 느리다. 이유는

1) 가상머신 상에서 실행되는 인터프리터 언어
2) 호출시마다 컨텍스트 스위칭 발생
3) 내장 SQL에 대한 Recursive Call(재귀호출) 발생

오라클은 자바처럼 함수나 프로시저를 컴파일시 바이트코드로 생성해서 데이터 딕셔너리에 저장하여 이를 해석할 수 있는 가상머신만 있으면 어디서든 실행할 수 있다.

__효과적인 인덱스 구성을 통한 함수호출 최소화__ :
    -- 회원테이블을 full scan 방식으로 읽어 함수를 레코드 건수만큼 수행된다.
    select /*+ full(a) */ *
    from 회원 a
    where 암호화된_전화번호 = encryption(:phone_no)

    -- 다른 조건이 있는 경우 조건절을 만족하는 건수만큼 수행된다.
    select /*+ full(a) */ *
    from 회원 a
    where 생년 = '1987'
    and 암호화된_전화번호 = encryption(:phone_no)

인덱스를 생년 + 암호화된_전화번호 순으로 구성하면 암호화된_전화번호도 생년과 함께 인덱스 액세스 조건으로 사용되어 함수는 단 한 번만 수행된다.

## 3.4 인덱스 설계
### 3.4.1 인덱스 설계가 어려운 이유
인덱스를 많이 생성하게 되면 관리비용과 시스템 부하를 증가 시키는 요인이 된다.

1) DML 성능 저하
2) 데이터베이스 사이즈 증가(디스크공간 낭비)
3) 데이터베이스 관리 및 운영 비용 상승

데이터를 삽입하는 경우 인덱스에도 데이터를 입력해야하고, 정렬 상태를 유지해야 하므로 수직적 탐색을 통해 입력할 블록을 찾는다. 블록의 여유 공간이 없으면 인덱스 분할도 발생한다. 데이터를 삭제할때도 마찬가지.

### 3.4.2 가장 중요한 두 가지 선택 기준
결합 인덱스를 구성할 때 기준
1) 조건절에 사용하거나, 자주 사용하는 컬럼을 선정
2) 선정된 조건중 '='으로 자주 조회하는 컬럼을 앞쪽에 두어야 한다.

### 3.4.3 스캔 효율성 이외의 판단 기준
* 수행빈도
* 업무상 중요도
* 클러스터링 팩터
* 데이터량
* DML 부하
* 저장공간
* 인덱스 관리 비용 등

위 기준 중 가장 중요한 하나를 뽑자면 수행 빈도이다. 자주 수행하지 않는 SQL이면 인덱스 스캔과정에 약간의 비효율이 있어도 큰 문제가 아닐 수 있다.

ex) NL방식으로 조인시 Outer쪽에서 액세스하는 인덱스는 스캔 과정에 비효율이 있더라도 큰 문제가 아닐 수 있다. 반대로 Inner 쪽 인덱스 스캔과정에서 비효율이 있다면 이는 성능에 큰 문제를 야기할 수 있다.

### 3.4.4 공식을 초월한 전략적 설계
조건절 패턴이 여러개일 때 조건절 패턴의 수만큼 인덱스를 만들 수 없다. 전문가라면 그 중 최적을 달성해야할 가장 핵심적인 액세스 경로 한 두개를 전략적으로 선택해서 최적 인덱스를 설계하고, 나머지 액세스 경로는 약간의 비효율이 있더라도 목표 성능을 만족하는 수준으로 인덱스를 구성할 수 있어야한다.

### 3.4.5 소트 연산을 생략하기 위한 컬럼 추가
인덱스는 항상 정렬 상태를 유지하므로 조건절에 사용하지 않는 컬럼이라도 소트 연산을 생략할 목적으로 인덱스 구성에 포함시킴으로써 성능 개선을 도모할 수 있다. *'='이 아닌 조건절 컬럼들은 반드시 ORDER BY 컬럼보다 뒤쪽에 두어야 소트 연산을 생략할 수 있다. (ORDER BY할 컬럼들이 앞쪽으로! 컬럼 순서 중요) I/O 를 최소화 하면서도 소트 연산을 생략하려면

1) '=' 연산자로 사용한 조건절 컬럼 선정
2) ORDER BY 절에 기술한 컬럼 추가
3) '=' 연산자가 아닌 조건절 컬럼은 데이터 분포를 고려해 추가 여부 결정

__IN조건은 '='이 아니다__ :

    select 고객번호, 고객명, 거주지역, 혈액형, 연령
    from 고객
    where 거주지역 = '서울'
    and 혈액형 in('A', 'O')
    order by 연령

IN조건이 '='이 되려면 IN-List Iterator 방식으로 풀려야한다. (UNION ALL사용) 하지만 위 경우에서 소트연산을 생략하려면 IN-List Iterator 방식으로 풀려서는 안 된다. IN 조건절을  인덱스 액세스 조건이 아닌 필터 조건으로 사용해야한다. 따라서 인덱스의 순서를 '거주지역 + 연령 + 혈액형' 순으로 구성해야한다.

### 3.4.6 결합 인덱스 선택도
인덱스 생성여부를 결정시 선택도가 충분히 낮은지가 중요한 판단기준이다. 선택도란 전체 레코드 중 조건절에 의해 선택되는 레코드 비율을 말하며 선택도에 총 레코드 수를 곱해서 카디널리티를 구한다. *선택도가 높은 인덱스는 생성해봐야 효용가치가 별로 없다.(테이블 액세스가 많이 발생하기 때문)

__컬럼 순서 결정 시, 선택도 이슈__ : 인덱스 설계시 항상 사용하는 컬럼은 앞쪽에 두고 그 중 '=' 조건을 앞쪽에 위치 시킨다. (옵션보다는 필수가 앞쪽에, Between 보다는 = 가 앞쪽에!) 즉 인덱스 생성 여부 결정시 선택도가 중요하지만 컬럼 간 순서를 결정할 때는 각 컬럼의 선택도보다 필수, 조건 여부, 연산자 형태가 더 중요한 판단 기분이다.

### 3.4.7 중복 인덱스 제거
244~248p

### 3.4.8 인덱스 설계도 작성